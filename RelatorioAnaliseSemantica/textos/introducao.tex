\section{Introdução}

A análise semântica é responsável por checar a consistência semântica do
programa fonte a partir da árvore sintática e da tabela de símbolos. Nela é
realizada a verificação estática do programa por meio da verificação de tipos e
da verificação sintática do código, permitindo dessa forma a detecção de erros
de tipos nos códigos fonte.

A análise semântica é realizada sobre a árvore sintática através de regras de
produção: síntese de tipo, inferência lógica e regras lógicas. A seguir será
apresentado a forma que utilizamos para realizar a verificação de tipos - por
meio de síntese e inferência de tipo - no nosso compilador exemplificando as
ações semânticas utilizadas e as restrições que introduzimos para definir o
nosso contexto - operações de consulta OCL.

\newpage
\section{Análise Semântica}

Na análise semântica implementada no projeto, realizamos verificação e conversão
de tipos e a verificação estática.

Para realizarmos tal análise, foi necessário a criação de construções
auxiliares, como é o caso da classe Java Elemento colocada no pacote util
(util é um dos pacotes do projeto - foram usados pacotes para melhor organização
do compilador em desenvolvimento), a qual é utilizada nas ações semânticas que
adicionamos às produções da gramática. No Listing \ref{listEl} é
apresentado um exemplo de utilização da classe Elemento em uma ação semântica
implementada.

\begin{lstlisting}[frame=single, label=listEl, caption={Exemplo de utilização da
classe Elemento nas ações semânticas}]
oclExpressionAux ::= logicalOperator relationalExpression:r oclExpressionAux {:
	Elemento rel = (Elemento) r;  
	if(rel.getAtributo("tipo") != "Boolean"){
		LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(rel.toString(), "Boolean"));
	}
	RESULT = rel; 
:} 
\end{lstlisting}

Nesse exemplo, é verificado se o tipo do atributo de uma expressão relacional é
diferente de Boolean (não é booleano), caso o tipo do atributo não seja
booleano, é adicionado um erro ao log semântico informando o ocorrido, caso
contrário a variável do tipo Elemento é atribuída a RESULT (o resultado da ação
semântica).
 
Também foi implementado um Parser para o XMI fornecido como entrada para a
análise do compilador em desenvolvimento. O parser é usado pelo analisador
semãntico para verificar a existência das classes - tipos do modelo, atributos e
operações presentes nas consultas informadas ao compilador. No Listing
\ref{listXmi} é apresentado um exemplo de uso do parser XMI.

\begin{lstlisting}[frame=single, label=listXmi, caption={Exemplo de uso do
Parser XMI}]
packageDeclaration ::= 
{:
	XMIParserBasic.getInstancia().setPackage("");
:} 
packageDeclarationAux;
\end{lstlisting}

No exemplo anteriormente ilustrado, na regra de produção para o caso da não
utilização de pacotes no início do programa fonte, o parser do XMI é instanciado
recebendo um pacote vazio ('''') para indicar que o programa fonte não possui a
declaração de um pacote no seu código.

\subsection{Verificação de Tipos}

Na verificação de tipos do programa, pode-se realizar a atribuição de expressão
de tipo a cada componente do programa fonte. Estas expressões devem estar em
conformidade com regras lógicas chamadas de sistema de tipo. A verificação
também permite detectar erros de tipos nos programas.

\subsubsection{Síntese de Tipo}
A síntese de tipos é realizada com o as funções \textit{tiposEquivalentes(t1,
t2)} e \textit{max(t1, t2)} da classe Elemento; a função tiposEquivalentes(t1,
t2) verifica se os tipos t1 e t2 são equivalentes e a função max(t1, t2) utiliza
dois tipos t1 e t2 e retorna o máximo dos dois tipos na hierarquia de
alargamento. No Listing \ref{listTE} a função tiposEquivalentes é apresentada.
No Listing \ref{lstMax} é apresentada a função max.

\begin{lstlisting}[frame=single, caption={Função tiposEquivalentes}, label =
listTE] 
public static boolean tiposEquivalentes(String esperado, String
passado){
		
		
		if(esperado.equalsIgnoreCase(passado)){
			return true;
		}
		
		if(ehCollection(esperado) && ehCollection(passado)){
			if(tiposEquivalentes(tipoCollection(esperado), tipoCollection(passado)))
				return true;
		}
		
		if(esperado.equalsIgnoreCase("Real") || passado.equalsIgnoreCase("Integer")){
			if(esperado.equalsIgnoreCase("Integer") || passado.equalsIgnoreCase("Real")){
				return true;
			}
		}
		
		if(XMIParserBasic.getInstancia().getSuperType(passado, esperado) != null){
			return true;
		}
		
		return false;		
	}
\end{lstlisting}

\begin{lstlisting}[frame=single, label=lstMax, caption={Função max}]
public static String max(String esperado, String passado) {
		
		if(tiposEquivalentes(esperado, passado)){
			
			if(esperado.equalsIgnoreCase(passado)){
				return esperado;
			}
			
			if(esperado == "Real" || passado == "Integer"){
				return "Real";
			}
			if(esperado == "Integer" || passado == "Real"){
				return "Integer";
			}
			
			return XMIParserBasic.getInstancia().getSuperType(passado, esperado);
			
		}
		return null;
	}
\end{lstlisting}

A função tiposEquivalentes retorna verdadeiro caso os tipos passados como
parâmetro sejam equivalentes e falso caso contrário. A função max retorna a
String correspondente ao tipo máximo na hierarquia de alargamento.

\subsubsection{Inferência de Tipo}

A inferência de tipos é realizada com o uso da função
\textit{tiposEquivalentes}, apresentada no Listing \ref{listTE} e é tratada por
meio da utilização dos subtipos de um determinado tipo usado como argumento para
alguma função.

\subsubsection{Coerção}

A coerção é tratada com a função \textit{coercao(valor, tipo, novoTipo)} da
classe Elemento, que recebe três argumentos: valor cujo tipo sofrerá coerção,
tipo o tipo atual do valor e novoTipo o novo tipo do valor após a coerção. No
Listing \ref{coer} é apresentado o código para a função coercao.

\begin{lstlisting}[frame=single, label=coer, caption={Função coercao}]
public static String coercao(String valor, String tipo, String novoTipo){
		if(tipo == "Integer" && novoTipo == "Real"){
			Integer temp = Integer.parseInt(valor);
			Double temp2 = temp.doubleValue();
			return temp2.toString();			
		}
		if(tipo == "Real" && novoTipo == "Integer"){
			Double temp = Double.parseDouble(valor);
			Integer temp2 = temp.intValue();
			return temp2.toString();			
		}
		return valor;
	}
\end{lstlisting}

Na função coercao ocorre a coerção entre os tipos \textit{Integer} e
\textit{Real} e vice-versa.

\subsection{Verificação Estática}

Na verificação estática usamos ações semânticas para cada um das regras de
produção da gramática. No Listing \ref{listAS} é exemplificado uma das
ações semânticas usadas na análise semântica.

\scriptsize
\begin{lstlisting}[frame=single, label = listAS, caption={Exemplo de uma
ação semântica}] 
packageDeclaration ::=  PACKAGE pathName:pn {:
	XMIParserBasic.getInstancia().setPackage(pn.toString());
	if(!XMIParserBasic.getInstancia().existsPackage()){
		LoggerSemantico.getInstance().addError(StringErro.packageInvalido(pn.toString()));
		throw new ErroFatal();
	}
:}  
packageDeclarationAux ENDPACKAGE
\end{lstlisting} 
\normalsize

A ação semântica anterior está asssociada à regra de produção:
\verb!packageDeclaration ::= PACKAGE pathName! \verb!packageDeclarationAux ENDPACKAGE!, que é a regra de produção inicial da gramática. Nesta ação semântica, o parser do XMI
é instanciado recebendo como pacote o valor de pn.toString() (variável usada para
referenciar o valor de pathName), caso o pacote pn não exista no modelo, o erro
é adicionado a um log de erros e uma exceção do tipo ErroFatal é
lançada. Caso o pacote exista parte-se para a verificação das demais ações
semânticas.

\newpage
\section{Conclusão}

Nessa etapa do projeto, a última etapa de análise,  construímos o analisador
semântico do nosso compilador, usamos o JCup para adicionar as ações semânticas
ao analisador sintático. Com isso foi gerada a classe Java AnaliseSemantica.java
que representa o analisador. O desenvolvimento do projeto nos proporcionou
colocar em prática a teoria que vimos em sala de aula, uma vez que precisamos
adicionar semântica às nossas regras de produção da gramática, para podermos
restringir nosso compilador ao contexto de operações de consulta, bem como
verificar a semântica das especificações OCL que serão fornecidas ao mesmo.

A grande vantagem do desenvolvimento de um projeto é, conforme dito acima,
termos a oportunidade de aplicar os conceitos vistos.

