\section{Análise Léxica}

O analisador léxico, lê caracteres da entrada e os agrupa em lexemas,
produzindo um conjunto de tokens e interagindo com a tabela de símbolos. Na
análise léxica ocorre a remoção de espaços em branco e comentários, a correlação
das mensagens de erros com o programa fonte, o início da construção da tabela de
símbolos e a expansão de macros.

\subsection{Ferramenta JFlex}

A ferramenta \textbf{JFlex} gera analisadores léxicos em \textbf{Java} a partir
da especificação de expressões regulares e trechos de código associados a cada
expressão. A especificação referida é escrita utilizando a linguaguem JFlex (um
clone da linguagem \textbf{lex}), que tem como extensão \textbf{.flex}.

\begin{figure}[h] 
	\includegraphics{imagens/analiseLexica.png}
	\caption{(Esquema - ferramenta JFlex.)}
\end{figure}

O esquema acima, ilustra a ferramenta JFlex recebendo como entrada o arquivo
\textbf{AnaliseLexica.flex} e gerando a classe
\textbf{AnaliseLexica.java}. Em linhas gerais, o código gerado lê um arquivo de entrada, extrai cadeias que estão de acordo com as expressões regulares definidas e executa o código associados as expressões.

\subsection{Linguagem JLex}
	
O arquivo \textbf{AnaliseLexica.flex} é divido em três seções separadas por
'\%\%'. A primeira seção serve para incluir código do usuário, ou seja, declarações de imports, classes e métodos auxiliares, que serão copiados diretamente para o topo do arquivo gerado.  A segunda seção é o espaço reservado para especificar diretivas, ou seja, declarações de macros (que definem as expressões regulares) e nomes de estados. Na última seção são definidas as ações para cada regra especificada anteriormente.

\subsection{Explicitando o arquivo AnaliseLexica.flex}

\scriptsize
\begin{lstlisting}[frame=single, caption={AnaliseLexica.flex}]
package analise_lexica;

import java_cup.runtime.*;
import util.sym; 

%%
%class AnaliseLexica
%unicode
%cup
%line
%column

%{
	StringBuilder string = new StringBuilder();
	
	private Symbol symbol(int tokenname) {
		Symbol symbol = new Symbol(tokenname, yyline, yycolumn, yytext());
		return symbol;
	}
	private Symbol symbol(int tokenname, String value) {
		Symbol symbol = new Symbol(tokenname, yyline, yycolumn, value);
		return symbol;
	}
%}

lineterminator = \n|\r|\n\r|\r\n
inputcharacter = [^\r\n]
whitespace     = {lineterminator}|[ \f\t]
paragraphcomment  = ("/*"~"*/")(~"*/")*
linecomment       = "--" {inputcharacter}* {lineterminator}
comments          = {linecomment} | {paragraphcomment} 

digit  = [0-9] 
letter = [A-Za-z] | [_] 
alpha  = {letter} | {digit} 
identifier = {letter}{alpha}*

%state STRING
stringdelimiter = \'
integer    = -?{digit}+  
real       = {integer}("\."{digit}+)?([eE][+-]?{digit}+)?
boolean = "true"|"false"    
collections = "Set"|"Bag"|"Sequence"|"OrderedSet"|"Collection"

%%

<YYINITIAL>  {whitespace} {  }    
<YYINITIAL>  {comments}   {  }	
<YYINITIAL>  "::"         { return symbol(sym.PATHNAME); } 
<YYINITIAL>  "."          { return symbol(sym.DOT); }
<YYINITIAL>  "->"         { return symbol(sym.COLLECTIONOPERATION); }   
<YYINITIAL>  ":"          { return symbol(sym.COLON); }  
<YYINITIAL>  "("          { return symbol(sym.LEFT_PAR); } 
<YYINITIAL>  "["          { return symbol(sym.LEFT_BRK); } 
<YYINITIAL>  "{"          { return symbol(sym.LEFT_BRA); } 
<YYINITIAL>  ")"          { return symbol(sym.RIGHT_PAR); } 
<YYINITIAL>  "]"          { return symbol(sym.RIGHT_BRK); } 
<YYINITIAL>  "}"          { return symbol(sym.RIGHT_BRA); }   	
<YYINITIAL>  ","          { return symbol(sym.COMMA); } 
<YYINITIAL>  "|"          { return symbol(sym.BAR); }
<YYINITIAL>  "="          { return symbol(sym.EQ); } 
<YYINITIAL>  "<>"         { return symbol(sym.NE); } 
<YYINITIAL>  "<="         { return symbol(sym.LE); } 
<YYINITIAL>  ">="         { return symbol(sym.GE); } 
<YYINITIAL>  "<"          { return symbol(sym.LT); } 
<YYINITIAL>  ">"          { return symbol(sym.GT); } 
<YYINITIAL>  "+"          { return symbol(sym.PLUS); } 
<YYINITIAL>  "-"          { return symbol(sym.MINUS); } 
<YYINITIAL>  "*"          { return symbol(sym.TIMES); } 
<YYINITIAL>  "/"          { return symbol(sym.DIVIDE); } 
<YYINITIAL>  "package"          { return symbol(sym.PACKAGE); }
<YYINITIAL>  "endpackage"       { return symbol(sym.ENDPACKAGE); }
<YYINITIAL>  "context"          { return symbol(sym.CONTEXT); }
<YYINITIAL>  "body"             { return symbol(sym.BODY); }
<YYINITIAL>  "if"               { return symbol(sym.IF); }
<YYINITIAL>  "then"             { return symbol(sym.THEN); }
<YYINITIAL>  "else"             { return symbol(sym.ELSE); }
<YYINITIAL>  "endif"            { return symbol(sym.ENDIF); }
<YYINITIAL>  "implies"          { return symbol(sym.IMPLIES); }
<YYINITIAL>  "and"              { return symbol(sym.AND); }
<YYINITIAL>  "or"               { return symbol(sym.OR); }
<YYINITIAL>  "xor"              { return symbol(sym.XOR); }
<YYINITIAL>  "not"              { return symbol(sym.NOT); }
<YYINITIAL>  "self"              { return symbol(sym.SELF); }
<YYINITIAL>  "String"              { return symbol(sym.STRINGTYPE); }
<YYINITIAL>  "Real"              { return symbol(sym.REALTYPE); }
<YYINITIAL>  "Boolean"              { return symbol(sym.BOOLEANTYPE); }
<YYINITIAL>  "Integer"              { return symbol(sym.INTEGERTYPE); }
<YYINITIAL>  {boolean}          { return symbol(sym.BOOLEAN); }
<YYINITIAL>  {collections}      { return symbol(sym.COLLECTION); }
<YYINITIAL>  {identifier}       { return symbol(sym.IDENTIFIER); } 
<YYINITIAL>  {real}             { return symbol(sym.REAL); } 
<YYINITIAL>  {integer}          { return symbol(sym.INTEGER); }
<YYINITIAL>  {stringdelimiter}  { string.setLength(0); yybegin(STRING); }
<STRING>  [^\n\r\'\\]+          { string.append( yytext()); }
<STRING>  \\t                   { string.append('\t'); }
<STRING>  \\n                   { string.append('\n'); }
<STRING>  \\r                   { string.append('\r'); }
<STRING>  \\\'                  { string.append('\''); }
<STRING>  \\                    { string.append('\\'); }
<STRING> {stringdelimiter} 		{ yybegin(YYINITIAL); return symbol(sym.STRING, string.toString());}

.|\n {throw new Error("Lexema não reconhecido pela linguagem OCL: <"+ yytext()+">" + " Linha: "+ (yyline + 1) + " Coluna: "+ (yycolumn + 1)+"\r");}
              
\end{lstlisting}
\normalsize

A seguir será explicado o código do arquivo AnaliseLexica.flex.

\subsection{Primeira Seção}

\subsubsection{Declaração de pacotes e \textit{imports}}

Na primeira seção são descritos trechos de código java. Na linha 1 é definido o
pacote \verb!analise_lexica!, no qual a classe gerada (em java) ficará,
nesse caso, a classe gerada será AnaliseLexicaOCL.java. Nas linhas 3 e 4 são especificados os
\textit{imports} para as classes do pacote \verb!java_cup.runtime.*! e
\textit{sym.java}. Utilizou-se o pacote \verb!analise_lexica! visando organizar
e tornar fácil a manutenção das classes java construídas durante o desenvolvimento do projeto. As classes importadas são necessárias para a manipulação dos tokens no código gerado.

\subsection{Segunda Seção}

\subsubsection{Definição das opções a serem usadas}

Nas linhas 7 a 11 são descritas as diretivas (opcionais). Na linha 7, define-se
o nome da classe que será gerada por meio da diretiva \verb!%class!, nesse caso,
o nome da classe é AnaliseLexica. Na linha 8, usa-se a diretiva \verb!%unicode!,
que define o conjunto de caracteres (UNICODE) que o analisador reconhecerá ao ler um
arquivo textual. Na linha 9, a diretiva \verb!%cup! indica compatibilidade com
o analisador sintático CUP. Nas linhas 10 e 11, as diretivas \verb!%line! e
\verb!%column! permitem utilizar as variáveis \textbf{yyline} e
\textbf{yycolumn}, que armazenam o número da linha e da coluna, respectivamente,
do arquivo que está sendo lido pelo analisador léxico.

\subsubsection{Declaração de variáveis e métodos}

Na linha 14, declara-se a variável \textit{string}, do tipo StringBuilder, que
será usada para armazenar os caracteres string
encontrados durante a etapa de Análise Léxica. Das linhas 16 a 19 é especificada a função \textit{symbol}, que será
usada para tratar tokens que não possuem 'valor-atributo' (e.g. palavras
reservadas da linguagem). Nessa função é criado um objeto Symbol, que armazena
informações (nome, linha e coluna onde está localizado no arquivo) sobre o token
e, em seguida, retornado.

Entre as linhas 20 e 22, a função \textbf{symbol} sofre uma sobrecarga para
lidar com os tokens que possuem o par: \verb!<nome-token, valor-atributo>!. Seu
funcionamento é similar a função \textit{symbol} (definida anteriormente). Esta
funções serão utilizadas pelo analisador sintático.

\subsubsection{Expressões Regulares}

A seguir são descritas as expressões regulares utilizadas para definir um
subconjunto da linguagem OCL. Este subconjunto se preocupa com os símbolos da linguagem que cobrem a parte de Operações de Consulta e os conceitos que estão ligados a esta parte, como por exemplo, Coleções, Operadores, dentre outros.

A especificação segue com as declarações de macros. Macros são definições de
expressões regulares usadas para tornar o código mais fácil de entender. Uma
declaração de macro consiste no identificador da macro, seguido do símbolo =,
seguido pela expressão regular que a representa: \verb!<nome = definição>!. Em
flex, para referenciar uma macro já criada, basta colocá-la entre \verb!{ }!.

\subsubsection{Delimitadores de linha}

Nas linhas 26 a 28 são declaradas as macros para tratar delimitação de linha e
espaço em branco. \textbf{lineterminator}, definida pela expressão
\verb!\n|\r|\n\r|\r\n!, é utilizada para reconhecer os terminadores de linha:
\verb!\n!, \verb!\r! e suas combinações. \textbf{inputcharacter}, definida pela
expressão regular: \verb![^\r\n]!, reconhece qualquer caractere, exceto os caracteres especiais \verb!\r! e/ou \verb!\n!. \textbf{whitespace}, definida pela expressão \verb!{lineterminator}|[ \f\t]!, reconhece os espaços em branco, tabulações e quebras de linha contidas no arquivo fonte do programa que está sendo analisado.

\subsubsection{Comentários}

Os comentários em OCL podem ser de dois tipos, conforme a Especificação de OCL,
pg. 127. Comentários de linha, representados por \verb!--! seguidos por qualquer
sequência de caracteres que se encontrem na mesma linha, e comentários de
parágrafo - representados por \verb!/*! seguido por qualquer cadeia de
caracteres e \verb!*/!, qualquer cadeia delimitada por \verb!/*! e \verb!*/!
será desconsiderada pelo analisador léxico.

Na linha 29 é definida a macro para comentário de parágrafo
\textbf{paragraphcomment}, que possui a expressão regular
\verb!("/*"~"*/")(~"*/")*!, indicando que pode existir qualquer cadeia entre
\verb!/*! e \verb!*/!, inclusive eles próprios. \verb!("/*"~"*/")! permite que
exista qualquer cadeia entre \verb!/*! e \verb!*/!, exceto \verb!*/!. A
concatenação com \verb!(~"*/")*! permite incluir a cadeia \verb!*/! dentre as
cadeias que fazem parte do comentário.

Na linha 30 é definida a macro para comentário de linha \textbf{linecomment},
que consiste em: \verb!"--" {inputcharacter}* {lineterminator}!, um \verb!--!
seguido por qualquer sequência de caracteres, exceto quebra de linhas.

Na linha 31 é definida a macro para ambos os tipos de comentários
\textbf{comments} à qual possui a expressão regular: \verb!{linecomment} | {paragraphcomment}!, indicando que um comentário pode ser de linha ou de coluna.

\subsubsection{Alfa numéricos}

Na linha 33 é definida a macro \textbf{digit} cuja expressão é \verb![0-9]!, que
indica que um dígito pode ser qualquer valor no intervalo de 0 a 9 (e.g.
\textbf{5} é um \textbf{digit}). 
Na linha 34 é definida a macro para letras ou
sublinhado \textbf{letter}, que possui como expressão regular: \verb![A-Za-z] |[_]!, podendo um \textbf{letter} ser qualquer letra maiúscula, minúscula ou
sublinhado. 
Na linha 35 é definida a macro \textbf{alpha} que consiste numa letra ou
sublinhado ou um digito, e possui expressão: \verb!{letter} | {digit}!.

\subsubsection{Identificadores}

Os identificadores são usados para o casamento dos padrões com os nomes de
funções, procedimentos, variáveis, ou outras expressões que representem
identificadores para as linguagens de programação. Em OCL, um identificador deve
ser iniciado com uma letra ou sublinhado e pode ser seguido por qualquer
sequência de letras, sublinhados ou dígitos. Desta forma, na linha 36, a macro
\textbf{identifier} é definida com a seguinte expressão:
\verb!{letter}{alpha}*!, garantindo que todos os identificadores reconhecidos na Análise Léxica iniciarão com uma letra ou sublinhado e terá qualquer sequência de letras, sublinhados ou dígitos.

\subsubsection{Tipos Básicos}

A seguir serão explicadas as expressões regulares usadas para definir os tipos
básicos de OCL \verb!(pg. 74 [KLEPPE])!.

\subsubsection{Tipo String}

Na linha 38 é declarado o estado \verb!STRING!, que será usado na parte das
regras léxicas para auxiliar no reconhecimento de strings. Na linha 39 é
definida a macro \textbf{stringdelimiter}, que é representada pela expressão
\verb!\'!. Serve para reconhecer o delimitador de string, no início e fim, que é
representado por \verb!'!.

\subsubsection{Tipo Integer}

Na linha 40 é definida a  expressão para o tipo Integer \textbf{integer}, com a
expressão: \verb!-?{digit}+!. Iniciando com um \textbf{-} unário opcional
seguido pela macro \textbf{digit}, definida anteriormente, a
expressão faz referência a \textbf{digit} da forma \verb!{digit}!. Em seguida aparece o símbol \textbf{+}, indicando que a sequência anterior não pode ser vazia e representando o conjunto de qualquer
sequência de dígitos. \textbf{12} é um exemplo do tipo Integer.

\subsubsection{Tipo Real}

Na linha 41 é definida a expressão para o tipo Real \textbf{real}. Baseado na macro \textbf{integer}, definida anteriormente, ela pode
ser subdividida em três subexpressões para facilitar a explicação. A expressão inicia com
\verb!{integer}!, indicando que a cadeia começa com qualquer elemento do
conjunto dos inteiros, seguida por  \verb!("\."{digit}+)?!, indicando que a
cadeia pode ser vazia ou então formada pelo símbolo \textbf{.} concatenada por
qualquer elemento do conjunto dos inteiros positivos. Para finalizar, a
subexpressão \verb!([eE][+-]?{digit}+)?!, indica que o número, representado pela
cadeia \verb!{integer}("\."{digit}+)?!, pode ser ainda ''elevado'' a qualquer
elemento do conjunto dos inteiros positivos \verb!({digit}+)!. O termo
''elevado'' é representado pela cadeia \verb![eE]!, que por sua vez, é
concatenada com a cadeia \verb![+-]?!, indicando se o número ''elevado'' será
positivo ou negativo, ou uma cadeia vazia. \textbf{1.23e3} é um exemplo do tipo
Real.

\subsubsection{Tipo Boolean}

Na linha 42 é definida a expressão para o tipo Boolean \textbf{real}
\verb!"true"|"false"!, indicando que o tipo Boolean é formado pelas palavras reservadas \textbf{true} e \textbf{false}.

\subsubsection{Tipos Compostos - Coleções}

Na linha 43 é definida a expressão \textbf{collections}
\verb!"Set"|"Bag"|"Sequence"|"OrderedSet"!, que representa os tipos de coleções de OCL, ou seja, as palavras reservadas que
representam cada um dos tipos de coleções: \textbf{Set, Bag, Sequence e
OrderedSet} \verb!(pg. 137 [KEPLLE])!.

\subsection{Terceira Seção}

Na terceira seção são descritas as regras das expressões regulares. Todas as
regras seguem o seguinte padrão: \verb!<estado> expressão { ação }!. O
analisador léxico vai lendo a entrada e procurando a sequência mais longa de caracteres. Caso mais de uma regra case com a sequência mais longa, escolhe-se aquela que foi definida primeiro. No arquivo AnaliseLexica.flex, na terceira seção, são manipulados dois estados. O estado inicial (YYINITIAL) e o estado que serve para auxiliar no reconhecimento de String (STRING).

Todas as ações das regras, que aparecem nas linhas 49 a 101, utilizam a função
\textit{symbol} (definada na \textbf{Segunda Seção}) para retornar o objeto
Symbol (que contém as informações sobre o token que está associado a expressão daquela regra). É
passado como argumento para a função \textit{symbol} o nome do token.

\subsubsection{Espaço e comentário}

Nas linhas 47 e 48 são tratadas as expressões que reconhecem espaço em branco e comentários, respectivamente. Não é executada nenhuma ação para estas duas expressões, ou seja, o analisador está removendo estas cadeias, que são desnecessárias para realizar o agrupamento dos tokens.

\subsubsection{Nomes de pacotes, operação de coleção, ponto e dois pontos} 

A regra da linha 49 trata o terminal \verb!::!, que no escopo do projeto,
servirá para referenciar tipos em outros pacotes, ou seja, permite navegar nos
pacotes (de UML) até chegar numa classe desejada. Exemplo: \verb!context NomePacote1::NomePacote2::NomeTipo!.  Na linha 50, a regra trata o símbolo
\verb!.!, que no escopo do projeto, é usado para acessar atributos em classes e
permitir executar uma operação a partir de um objeto (que não seja coleção).
Exemplo: \verb!Classe1.atributo1.operacao1()!. Na linha 51, a regra trata o
terminal \verb!->!, utilizado para executar operações sobre objetos do tipo
Collections. Exemplo: \verb!Bag1->select (...)!. O terminal \verb!:!, associado
a regra da linha 52, é utilizado de diversas formas no escopo deste projeto. As
mais comuns são: determinar o início da especificação do corpo de uma função
\verb!(body:)!, permitir associar o tipo de Objeto a uma variável no iterador
\textit{forAll}, especificar o tipo de retorno de uma função. Exemplos:
\verb!body: self.atributo, forAll(a : TipoObjeto | expressão)}!.

\subsubsection{Parênteses, Colchetes, Chaves, Vírgula e Barra}

Os parênteses, tratados nas regras das linhas 53 e 56, são usados em operações,
para especificar os argumentos e para determinar a precedência de expressões, em
geral, por exemplo: a expressão \verb!5 - 2 * 10 + 5! resultaria em \verb!-10!,
entretanto, se escrevêssemos \verb!(5 - 2) * (10 + 5)!, o resultado seria
\verb!45!. Com isso, percebe-se que os parênteses mudaram a ordem em que foram
realizadas as operações. Os colchetes, tratados nas regras das linhas 54 e 57 no
escopo deste projeto, são utilizados mais comumente para acessar elementos de
classes compostas por conjunto de outros elementos. Por exemplo, a expressão:
\verb!classeA.conjuntoB[1]! terá como resultado o primeiro elemento do
\verb!conjuntoB!. 
As chaves, tratadas nas regras das linhas 55 e 58, são usadas
para definir coleções. Por exemplo: \verb!body: Set{1, 2, 3, 4}!. A vírgula,
tratada na regra da linha 59, é utilizada, no escopo deste projeto, para:
separar os argumentos das operações e separar elementos de uma coleção. A barra,
tratada na regra da linha 60, é utilizada em operações, como por exemplo:
\verb!self.employee->exists( p | p.forename = 'Jack' )!.

\subsubsection{Operadores}

Os operadores \verb!=, <>, <=, >=,  <, >, +, -, *, /,! tratados nas regras das
linhas 61 a 70, são utilizados para realizar operações em valores do tipo
Integer e Real. Os operadores \verb!= e <>! também são utilizados em operações
que envolvem valores do tipo String e do tipo Boolean.

\subsubsection{Keywords}

As palavras chaves da linguagem OCL necessárias para o escopo do projeto são:
\textbf{self} (denotar a instância do contexto), \textbf{package} (especificar
explicitamente a que pacote as expressões pertencem), \textbf{endpackage}
(delimita o ''fim do package''), \textbf{context} (especificar o contexto para
as expressões) e \textbf{body} (definir o corpo da operação) e são tratadas nas
regras das linhas 71 a 74 e na linha 84 (self). \verb!(pg. 13 e 14 [Especificação OCL])!


\subsubsection{Expressão Condicional if-then-else}

As regras das linhas 75 a 78 tratam os elementos que formam a expressão
condicional \verb!''if-then-else''!, são eles:  \textbf{if, then, else, endif}. 
\verb!(pg. 10 [Especificação OCL])!. Um exemplo de uma expressão condicional
\textbf{if-then-else}:  \verb!if balance > 5000 then 2 else 3 endif!.

\subsubsection{Operadores ''Booleanos''}

As regras das linhas 79 a 83 tratam os operadores ''booleanos'' (além dos já
comentados acima), são eles: \textbf{implies, and, or, xor e not} \verb!(pg. 123 [KEPLLE])!. Exemplo: \verb!forAll(elem | self->includes(elem) xor
s->includes(elem))!.

 \subsubsection{Nomes dos Tipos Básicos}
 
 As regas das linhas 85 a 88 tratam os nomes dos tipos String, Boolean,
 Real e Integer, utilizados para reconhecimento dos nomes dos tipos básicos de
 OCL e criação de tokens para eles.
 
 \subsubsection{Tipos básicos e identificador}
 
As regas das linhas 89 , 90, 92 e 93 tratam os tipos Boolean, Collection, Real e
Integer, respectivamente, baseados nas macros definidas anteriormente, na
\textbf{Segunda Seção}. Na linha 93, a regra trata a macro que define os
Identificadores (também explicada na \textbf{Segunda Seção}). Para auxiliar no
reconhecimento dos valores do tipo String, foi necessário criar o estado STRING.
Quando o analisador léxico encontra um delimitador de String (tratado na linha
94), um possível valor do tipo String poderá ser encontrado, das linhas 95 a
101, os caracteres que podem ser encontrados em Strings são tratados.

