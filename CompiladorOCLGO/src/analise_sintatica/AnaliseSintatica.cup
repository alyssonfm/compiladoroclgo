// CUP specification for a simple expression evaluator (no actions)
package analise_sintatica;
import java_cup.runtime.Symbol;

parser code {:
	
	public void report_error(String message, Object info) {
		Util.report_error(message, info);
	}

	public void syntax_error(Symbol cur_token) {
		Util.syntax_error(cur_token);
	}

	public void debug_message(String mess) {
		Util.debug_message(mess);
	}

	public void debug_shift(Symbol shift_tkn) {
		Util.debug_shift(shift_tkn);
	}

	public void debug_reduce(int prod_num, int nt_num, int rhs_size) {
		Util.debug_reduce(prod_num, nt_num, rhs_size);
	}
:};


/* Terminals (tokens returned by the scanner). */
terminal PACKAGE, ENDPACKAGE, CONTEXT, BODY, COLLECTION;
terminal DOT, COMMA, COLON, PATHNAME, LEFT_PAR, LEFT_BRK, LEFT_BRA, RIGHT_PAR, RIGHT_BRK, RIGHT_BRA;
terminal COLLECTIONOPERATION;
terminal EQ, NE, LE, GE, GT, LT;
terminal AND, OR, NOT, XOR, IMPLIES;
terminal IF, ELSE, THEN, ENDIF;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal Integer INTEGER;
terminal Double REAL;
terminal String STRING;
terminal IDENTIFIER, BOOLEAN;
terminal BAR;

/* Non terminals */
non terminal packageDeclaration;
non terminal packageDeclarationAux;
non terminal contextDeclaration;
non terminal operationContext;
non terminal operationContextAux;
non terminal bodyDeclaration;
non terminal operation;
non terminal operationParAux;
non terminal operationTypeAux;
non terminal oclExpression, oclExpressions, expression;
non terminal parameters;
non terminal variableExp;
non terminal pathName;
non terminal pathNameAux;
non terminal literalExp;
non terminal collectionLiteralExp;
non terminal collectionTypeIdentifier;
non terminal collectionLiteralParts;
non terminal collectionLiteralPart;
non terminal primitiveLiteralExp;
non terminal integerLiteral;
non terminal realLiteral;
non terminal stringLiteral;
non terminal booleanLiteral;
non terminal propertyCallExp;
non terminal modelPropertyCallExp;
non terminal operationCallExp;
non terminal attributeCallExp;
non terminal navigationCallExp;
non terminal associationCallExp;
non terminal arguments;
non terminal ifExp;
non terminal collectionType;
non terminal typeName;
non terminal variableDeclaration;
non terminal variableDeclarationTypeAux;
non terminal relationalExpression;
non terminal additiveExpression;
non terminal multiplicativeExpression;
non terminal unaryExpression;
non terminal oclExpressionAux;
non terminal unaryOperator;
non terminal multiplyOperator; 
non terminal addOperator;
non terminal relationalOperator;
non terminal logicalOperator;
non terminal loopExp;


/* Precedences */
 
precedence left COMMA;
precedence left IMPLIES;
precedence left AND, OR, XOR;
precedence left EQ, NE;
precedence left LE, GE, GT, LT; 
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left NOT;
precedence left LEFT_PAR, RIGHT_PAR;
precedence left COLLECTIONOPERATION, DOT; 

/*----------------------------------------------------------------*/
start with packageDeclaration;
/*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . */ 


/* The grammar */

packageDeclaration ::=  PACKAGE pathName packageDeclarationAux ENDPACKAGE
						| packageDeclarationAux;
packageDeclarationAux ::= contextDeclaration packageDeclarationAux |;
pathName ::= IDENTIFIER pathNameAux;
pathNameAux ::= PATHNAME pathName |;
contextDeclaration ::= CONTEXT operation;
operation ::= IDENTIFIER pathNameAux LEFT_PAR operationParAux RIGHT_PAR COLON operationTypeAux
			|IDENTIFIER LEFT_PAR operationParAux RIGHT_PAR COLON operationTypeAux;
operationParAux ::= parameters |;
operationTypeAux ::= typeName |;
parameters ::= variableDeclaration
			| variableDeclaration COMMA parameters; 
typeName ::= pathName
			| collectionType;
variableDeclaration ::= IDENTIFIER variableDeclarationTypeAux EQ oclExpression
						|IDENTIFIER variableDeclarationTypeAux;
variableDeclarationTypeAux ::= COLON typeName |;
oclExpression ::= IDENTIFIER; 
collectionType ::= collectionTypeIdentifier LEFT_PAR typeName RIGHT_PAR;
collectionTypeIdentifier ::= COLLECTION;

