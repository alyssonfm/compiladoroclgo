package core;
import java_cup.runtime.Symbol;
import util.sym;
import util.*;

parser code {:
	
	public void report_error(String message, Object info) {
		Util.report_error(message, info);
	}
	public void syntax_error(Symbol cur_token) {
		Util.syntax_error(cur_token);
	}
	public void debug_message(String mess) {
		Util.debug_message(mess);
	}
	public void debug_shift(Symbol shift_tkn) {
		Util.debug_shift(shift_tkn);
	}
	public void debug_reduce(int prod_num, int nt_num, int rhs_size) {
		Util.debug_reduce(prod_num, nt_num, rhs_size);
	}
:};

terminal PACKAGE, ENDPACKAGE, CONTEXT, BODY, COLLECTION, SELF;
terminal DOT, COMMA, COLON, PATHNAME, LEFT_PAR, LEFT_BRK, LEFT_BRA, RIGHT_PAR, RIGHT_BRK, RIGHT_BRA, BAR;
terminal COLLECTIONOPERATION;
terminal EQ, NE, LE, GE, GT, LT;
terminal AND, OR, NOT, XOR, IMPLIES;
terminal IF, ELSE, THEN, ENDIF;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal INTEGERTYPE, REALTYPE, BOOLEANTYPE, STRINGTYPE;
terminal Integer INTEGER;
terminal REAL;
terminal String STRING;
terminal IDENTIFIER, BOOLEAN;

non terminal packageDeclaration;
non terminal packageDeclarationAux;
non terminal contextDeclaration;
non terminal bodyDeclaration;
non terminal operation;
non terminal operationParAux;
non terminal oclExpression;
non terminal parameters;
non terminal pathName;
non terminal pathNameAux;
non terminal pathNameOperation;
non terminal collectionTypeIdentifier;
non terminal ifExp;
non terminal collectionType;
non terminal typeName;
non terminal variableDeclaration;
non terminal relationalExpression;
non terminal relationalExpressionAux;
non terminal additiveExpression;
non terminal additiveExpressionAux;
non terminal multiplicativeExpression;
non terminal multiplicativeExpressionAux;
non terminal postfixExpression;
non terminal postfixExpressionAux;
non terminal operationCall;
non terminal propertyCall;
non terminal propertyCallParameters;
non terminal declarator;
non terminal declaratorAux;
non terminal literalCollection;
non terminal expressionParameter;
non terminal expressionParameterAux;
non terminal qualifiers;
non terminal primaryExpression;
non terminal unaryExpression;
non terminal oclExpressionAux;
non terminal unaryOperator;
non terminal multiplyOperator; 
non terminal addOperator;
non terminal relationalOperator;
non terminal logicalOperator;
non terminal literal;
non terminal primaryTypes;
non terminal colonPathName;
 
precedence left COMMA;
precedence left IMPLIES;
precedence left AND, OR, XOR;
precedence left EQ, NE;
precedence left LE, GE, GT, LT; 
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left NOT;
precedence left LEFT_PAR, RIGHT_PAR;
precedence left COLLECTIONOPERATION, DOT; 

start with packageDeclaration;

packageDeclaration ::=  PACKAGE pathName:pn packageDeclarationAux ENDPACKAGE
						| packageDeclarationAux;
packageDeclarationAux ::= contextDeclaration packageDeclarationAux |;
pathName ::= IDENTIFIER:id pathNameAux:aux {: RESULT = id.toString() + aux.toString(); :};
pathNameAux ::= PATHNAME:pn pathName:path {: RESULT = "::" + path.toString(); :}  
				| {: RESULT = ""; :};
pathNameOperation ::= PATHNAME:pn pathName:path {: RESULT = "::"+ path.toString(); :};
contextDeclaration ::= CONTEXT operation:op bodyDeclaration;
bodyDeclaration ::= BODY COLON oclExpression;
operation ::= IDENTIFIER:id pathNameOperation:pno LEFT_PAR operationParAux:ope RIGHT_PAR COLON typeName:type
			  {: RESULT = id.toString() + pno.toString() + "(" + ope.toString() + ")" + ":" + type.toString(); :};
operationParAux ::= parameters:p {: RESULT = p.toString(); :}  
					| {: RESULT = ""; :};
parameters ::= variableDeclaration:v {: RESULT = v.toString(); :}
			| variableDeclaration:v COMMA parameters:p {: RESULT = v.toString() + "," + p.toString(); :};

collectionType ::= collectionTypeIdentifier:c LEFT_PAR typeName:t RIGHT_PAR 
				   {: RESULT = c.toString() + "(" + t.toString() + ")"; :};
collectionTypeIdentifier ::= COLLECTION:c {: RESULT = c.toString(); :};
			 
typeName ::= primaryTypes:p {: RESULT = p.toString(); :} 
			| pathName:pna {: RESULT = pna.toString(); :}
			| collectionType:c {: RESULT = c.toString(); :};

primaryTypes ::= STRINGTYPE:s {: RESULT = "String"; :} 
			| REALTYPE:r {: RESULT = "Real"; :}
			| BOOLEANTYPE:b {: RESULT = "Boolean"; :}
			| INTEGERTYPE:i {: RESULT = "Integer"; :};
			
literal ::= REAL:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "Real");
	RESULT = elem;
:}
| INTEGER:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "Integer");
	RESULT = elem;
:} 
| BOOLEAN:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "Boolean");
	RESULT = elem;
:} 
| STRING:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "String");
	RESULT = elem;
:};
			
variableDeclaration ::= IDENTIFIER:id COLON typeName:type {: RESULT = id.toString() + ":" + type.toString(); :};

oclExpression ::= relationalExpression:r oclExpressionAux:aux {:
	RESULT = r;
	if(aux != null){
		Elemento rel = (Elemento) r;
		if(rel.getAtributo("tipo") != "Boolean"){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(rel.toString(), "Boolean"));
		}
		
	}
	
:};
oclExpressionAux ::= logicalOperator relationalExpression:r oclExpressionAux {:
	Elemento rel = (Elemento) r;  
	if(rel.getAtributo("tipo") != "Boolean"){
		LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(rel.toString(), "Boolean"));
	}
	RESULT = rel; 
:} 
|;

relationalExpression ::= additiveExpression:add relationalExpressionAux:aux {:
	Elemento val = (Elemento) add;
	if(aux != null){
		Elemento auxElem = (Elemento) aux; 
		if((auxElem.getAtributo("operacao") != "=") && (auxElem.getAtributo("operacao") != "<>")){
			if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
				LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
			}
		}else if((auxElem.getAtributo("operacao") == "=") || (auxElem.getAtributo("operacao") == "<>")){
			if(!Elemento.tiposEquivalentes(val.getAtributo("tipo"), auxElem.getAtributo("tipo"))){
				LoggerSemantico.getInstance().addError(StringErro.tipoDiferentes(val.toString(), auxElem.toString()));
			}else{
				String tipoMax = Elemento.max(val.getAtributo("tipo"), auxElem.getAtributo("tipo"));
				val.valor = Elemento.coercao(val.valor, val.getAtributo("tipo"), tipoMax);
				val.setAtributo("tipo", tipoMax);
			}
		}
	}
	RESULT = val;
:}; 
relationalExpressionAux ::= relationalOperator:op additiveExpression:add relationalExpressionAux:aux {:
	Elemento val = (Elemento) add;
	val.setAtributo("operacao", op.toString());
	if((val.getAtributo("operacao") != "=") && (val.getAtributo("operacao") != "<>")){
		if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
		}
	}
	if(aux != null){
		Elemento auxElem = (Elemento) aux;
		if((auxElem.getAtributo("operacao") == "=") || (auxElem.getAtributo("operacao") == "<>")){
			if(!Elemento.tiposEquivalentes(val.getAtributo("tipo"), auxElem.getAtributo("tipo"))){
				LoggerSemantico.getInstance().addError(StringErro.tipoDiferentes(val.toString(), auxElem.toString()));
			}else{
				String tipoMax = Elemento.max(val.getAtributo("tipo"), auxElem.getAtributo("tipo"));
				val.valor = Elemento.coercao(val.valor, val.getAtributo("tipo"), tipoMax);
				val.setAtributo("tipo", tipoMax);
			}
		}
	}
	RESULT = val;
:} 
|;

additiveExpression ::= multiplicativeExpression:mult additiveExpressionAux:aux {:
	Elemento val = (Elemento) mult;
	if(aux != null){ 
		if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
		}
	}
	RESULT = mult;
:};

additiveExpressionAux ::= addOperator multiplicativeExpression:mult additiveExpressionAux {:
	Elemento val = (Elemento) mult;
	if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
		LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
	}
	RESULT = mult;
:} 
|;

multiplicativeExpression ::= unaryExpression:un multiplicativeExpressionAux:aux {:
	Elemento val = (Elemento) un;
	if(aux != null){ 
		if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
		}
	}
	RESULT = un;
:};
multiplicativeExpressionAux ::= multiplyOperator unaryExpression:un multiplicativeExpressionAux{:
	Elemento val = (Elemento) un;
	if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
		LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
	}
	RESULT = un;
:} 
|;

unaryExpression ::= unaryOperator:op postfixExpression:post {:
	Elemento val = (Elemento) post;
	if(op.toString() == "NOT"){
		if(val.getAtributo("tipo") != "Boolean"){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Boolean"));
		}
	}else if(op.toString() == "-"){
		if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
		}
	}
	val.valor = op.toString() + val.valor;
	RESULT = post;
:}
| postfixExpression:post {: RESULT = post; :};

postfixExpression ::= primaryExpression:pri postfixExpressionAux {: RESULT = pri; :};
postfixExpressionAux ::= operationCall propertyCall postfixExpressionAux |;

operationCall ::= COLLECTIONOPERATION {: RESULT = "->"; :} 
				  | DOT {: RESULT = "."; :};
				  
primaryExpression ::= literalCollection
					| literal:li {: RESULT = li; :}
					| propertyCall:p {: RESULT = p; :}
					| LEFT_PAR oclExpression:exp RIGHT_PAR {: RESULT = exp; :}
					| SELF
					| ifExp:exp {: RESULT = exp; :};

literalCollection ::= collectionTypeIdentifier LEFT_BRA expressionParameter RIGHT_BRA;
 
ifExp ::= IF:ifToken oclExpression:exp THEN oclExpression:exp1 ELSE oclExpression:exp2 ENDIF {:
	Elemento val = (Elemento) exp;
	Elemento val1 = (Elemento) exp1;
	Elemento val2 = (Elemento) exp2;
	
	Elemento res = new Elemento("Expressao Condicional", ifTokenleft, ifTokenright);
	res.setAtributo("tipo", val1.getAtributo("tipo"));
	
	if(val.getAtributo("tipo") != "Boolean"){
		LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Boolean"));
	}
	if(!Elemento.tiposEquivalentes(val1.getAtributo("tipo"), val2.getAtributo("tipo"))){
		LoggerSemantico.getInstance().addError(StringErro.tipoDiferentes(val1.toString(), val2.toString()));
	}else{
		res.setAtributo("tipo", Elemento.max(val1.getAtributo("tipo"), val2.getAtributo("tipo")));
	}
	
	RESULT = res;
:}
;

propertyCall ::= pathName qualifiers propertyCallParameters;

qualifiers ::= LEFT_BRK expressionParameter RIGHT_BRK|;

propertyCallParameters ::= LEFT_PAR expressionParameter RIGHT_PAR
						   |LEFT_PAR declarator expressionParameter RIGHT_PAR
						   |;
						   
declarator ::= IDENTIFIER declaratorAux colonPathName  BAR oclExpression;
declaratorAux ::= COMMA IDENTIFIER declaratorAux|;
colonPathName ::= COLON pathName |;

expressionParameter ::= oclExpression expressionParameterAux | IDENTIFIER expressionParameterAux |;
expressionParameterAux ::= COMMA oclExpression expressionParameterAux | COMMA IDENTIFIER expressionParameterAux |;

logicalOperator ::= AND | OR | XOR | IMPLIES;

relationalOperator ::= EQ {: RESULT = "="; :} 
|NE {: RESULT = "<>"; :}
|LE {: RESULT = "<="; :}
|GE {: RESULT = ">="; :}
|GT {: RESULT = "<"; :}
|LT {: RESULT = ">"; :};

addOperator ::= PLUS | MINUS;
multiplyOperator ::= TIMES | DIVIDE;
unaryOperator ::= MINUS {: RESULT = "-"; :}
|NOT {: RESULT = "NOT"; :};