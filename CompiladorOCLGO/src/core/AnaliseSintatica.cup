package core;
import java_cup.runtime.Symbol;
import util.sym;
import util.*;

parser code {:
	
	public void report_error(String message, Object info) {
		Util.report_error(message, info);
	}
	public void syntax_error(Symbol cur_token) {
		Util.syntax_error(cur_token);
	}
	public void debug_message(String mess) {
		Util.debug_message(mess);
	}
	public void debug_shift(Symbol shift_tkn) {
		Util.debug_shift(shift_tkn);
	}
	public void debug_reduce(int prod_num, int nt_num, int rhs_size) {
		Util.debug_reduce(prod_num, nt_num, rhs_size);
	}
:};

terminal PACKAGE, ENDPACKAGE, CONTEXT, BODY, COLLECTION, SELF;
terminal DOT, COMMA, COLON, PATHNAME, LEFT_PAR, LEFT_BRK, LEFT_BRA, RIGHT_PAR, RIGHT_BRK, RIGHT_BRA, BAR;
terminal COLLECTIONOPERATION;
terminal EQ, NE, LE, GE, GT, LT;
terminal AND, OR, NOT, XOR, IMPLIES;
terminal IF, ELSE, THEN, ENDIF;
terminal PLUS, MINUS, TIMES, DIVIDE;
terminal INTEGERTYPE, REALTYPE, BOOLEANTYPE, STRINGTYPE;
terminal Integer INTEGER;
terminal REAL;
terminal String STRING;
terminal IDENTIFIER, BOOLEAN;

non terminal packageDeclaration;
non terminal packageDeclarationAux;
non terminal contextDeclaration;
non terminal bodyDeclaration;
non terminal operation;
non terminal operationParAux;
non terminal oclExpression;
non terminal parameters;
non terminal pathName;
non terminal pathNameAux;
non terminal pathNameOperation;
non terminal collectionTypeIdentifier;
non terminal ifExp;
non terminal collectionType;
non terminal typeName;
non terminal variableDeclaration;
non terminal relationalExpression;
non terminal relationalExpressionAux;
non terminal additiveExpression;
non terminal additiveExpressionAux;
non terminal multiplicativeExpression;
non terminal multiplicativeExpressionAux;
non terminal postfixExpression;
non terminal postfixExpressionAux;
non terminal operationCall;
non terminal propertyCall;
non terminal propertyCallParameters;
non terminal declarator;
non terminal declaratorAux;
non terminal literalCollection;
non terminal expressionParameter;
non terminal expressionParameterAux;
non terminal qualifiers;
non terminal primaryExpression;
non terminal unaryExpression;
non terminal oclExpressionAux;
non terminal unaryOperator;
non terminal multiplyOperator; 
non terminal addOperator;
non terminal relationalOperator;
non terminal logicalOperator;
non terminal literal;
non terminal primaryTypes;
non terminal colonPathName;
 
precedence left COMMA;
precedence left IMPLIES;
precedence left AND, OR, XOR;
precedence left EQ, NE;
precedence left LE, GE, GT, LT; 
precedence left IF, THEN, ELSE, ENDIF;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDE;
precedence left NOT;
precedence left LEFT_PAR, RIGHT_PAR;
precedence left COLLECTIONOPERATION, DOT; 

start with packageDeclaration;

packageDeclaration ::=  PACKAGE pathName:pn packageDeclarationAux ENDPACKAGE
						| packageDeclarationAux;
packageDeclarationAux ::= contextDeclaration packageDeclarationAux |;
pathName ::= IDENTIFIER:id pathNameAux:aux {: RESULT = id.toString() + aux.toString(); :};
pathNameAux ::= PATHNAME:pn pathName:path {: RESULT = "::" + path.toString(); :}  
				| {: RESULT = ""; :};
pathNameOperation ::= PATHNAME:pn pathName:path {: RESULT = "::"+ path.toString(); :};
contextDeclaration ::= CONTEXT operation:op bodyDeclaration;
bodyDeclaration ::= BODY COLON oclExpression;
operation ::= IDENTIFIER:id pathNameOperation:pno LEFT_PAR operationParAux:ope RIGHT_PAR COLON typeName:type
			  {: RESULT = id.toString() + pno.toString() + "(" + ope.toString() + ")" + ":" + type.toString(); :};
operationParAux ::= parameters:p {: RESULT = p.toString(); :}  
					| {: RESULT = ""; :};
parameters ::= variableDeclaration:v {: RESULT = v.toString(); :}
			| variableDeclaration:v COMMA parameters:p {: RESULT = v.toString() + "," + p.toString(); :};

collectionType ::= collectionTypeIdentifier:c LEFT_PAR typeName:t RIGHT_PAR 
				   {: RESULT = c.toString() + "(" + t.toString() + ")"; :};
collectionTypeIdentifier ::= COLLECTION:c {: RESULT = c.toString(); :};
			 
typeName ::= primaryTypes:p {: RESULT = p.toString(); :} 
			| pathName:pna {: RESULT = pna.toString(); :}
			| collectionType:c {: RESULT = c.toString(); :};

primaryTypes ::= STRINGTYPE:s {: RESULT = "String"; :} 
			| REALTYPE:r {: RESULT = "Real"; :}
			| BOOLEANTYPE:b {: RESULT = "Boolean"; :}
			| INTEGERTYPE:i {: RESULT = "Integer"; :};
			
literal ::= REAL:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "Real");
	RESULT = elem;
:}
| INTEGER:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "Integer");
	RESULT = elem;
:} 
| BOOLEAN:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "Boolean");
	RESULT = elem;
:} 
| STRING:v {:
	Elemento elem = new Elemento(v.toString(), vleft, vright);
	elem.setAtributo("tipo", "String");
	RESULT = elem;
:};
			
variableDeclaration ::= IDENTIFIER:id COLON typeName:type {: RESULT = id.toString() + ":" + type.toString(); :};

oclExpression ::= relationalExpression:r oclExpressionAux:aux {:
	if(aux != null){
		Elemento rel = (Elemento) r;
		if(rel.getAtributo("tipo") != "Boolean"){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(rel.toString(), "Boolean"));
		}
	}
	
:};
oclExpressionAux ::= logicalOperator relationalExpression:r oclExpressionAux {:
	Elemento rel = (Elemento) r;  
	if(rel.getAtributo("tipo") != "Boolean"){
		LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(rel.toString(), "Boolean"));
	}
	RESULT = rel; 
:} 
|;

relationalExpression ::= additiveExpression:add relationalExpressionAux:aux {:
	Elemento val = (Elemento) add;
	if(aux != null){
		if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
			LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
		}
	}
	RESULT = val;
:}; 
relationalExpressionAux ::= relationalOperator additiveExpression:add relationalExpressionAux {:
	Elemento val = (Elemento) add;  
	if((val.getAtributo("tipo") != "Real") && (val.getAtributo("tipo") != "Integer") ){
		LoggerSemantico.getInstance().addError(StringErro.tipoInvalido(val.toString(), "Integer ou Real"));
	}
	RESULT = val;
:} 
|;

additiveExpression ::= multiplicativeExpression:mult additiveExpressionAux {: RESULT = mult;:};
additiveExpressionAux ::= addOperator multiplicativeExpression additiveExpressionAux |;

multiplicativeExpression ::= unaryExpression:un multiplicativeExpressionAux {: RESULT = un; :};
multiplicativeExpressionAux ::= multiplyOperator unaryExpression multiplicativeExpressionAux |;

unaryExpression ::= unaryOperator postfixExpression
					| postfixExpression:post {: RESULT = post; :};

postfixExpression ::= primaryExpression:pri postfixExpressionAux {: RESULT = pri; :};
postfixExpressionAux ::= operationCall propertyCall postfixExpressionAux |;
operationCall ::= COLLECTIONOPERATION 
				  | DOT;
				  
primaryExpression ::= literalCollection
					| literal:li {: RESULT = li; :}
					| propertyCall
					| LEFT_PAR oclExpression RIGHT_PAR
					| SELF
					| ifExp;

literalCollection ::= collectionTypeIdentifier LEFT_BRA expressionParameter RIGHT_BRA;
 
ifExp ::= IF oclExpression THEN oclExpression ELSE oclExpression ENDIF;

propertyCall ::= pathName qualifiers propertyCallParameters;

qualifiers ::= LEFT_BRK expressionParameter RIGHT_BRK|;

propertyCallParameters ::= LEFT_PAR expressionParameter RIGHT_PAR
						   |LEFT_PAR declarator expressionParameter RIGHT_PAR
						   |;
						   
declarator ::= IDENTIFIER declaratorAux colonPathName  BAR oclExpression;
declaratorAux ::= COMMA IDENTIFIER declaratorAux|;
colonPathName ::= COLON pathName |;

expressionParameter ::= oclExpression expressionParameterAux | IDENTIFIER expressionParameterAux |;
expressionParameterAux ::= COMMA oclExpression expressionParameterAux | COMMA IDENTIFIER expressionParameterAux |;

logicalOperator ::= AND | OR | XOR | IMPLIES;
relationalOperator ::= EQ | NE | LE | GE | GT | LT;
addOperator ::= PLUS | MINUS;
multiplyOperator ::= TIMES | DIVIDE;
unaryOperator ::= MINUS | NOT;